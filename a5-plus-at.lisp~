;;; ============================
;;;  CMPU-365, Fall 2014
;;;  a5-plus.lisp
;;;  ANDREW TERENZI
;;; ============================

;;; ======> Include your NAME in the above comment block!

;;; ======> If you make any changes to the a5.lisp file, include
;;;         comments *HERE* that describe those changes.  (See the
;;;         assignment instructions; you should only need *MINIMAL*
;;;         changes to a5.lisp.)

;;;  

;;;  COMPUTE-MOVE
;;; -------------------------------------------------------------
;;;  INPUT:  G, a CHESS struct
;;;  OUTPUT:  The best move according to MINIMAX with ALPHA-BETA
;;;   pruning, using the static eval func, EVAL-FUNC.  Searches to
;;;   a depth of *CUTOFF-DEPTH*.

(defun compute-move (g)
  (setf *node-count* 0)
  (let* ((best-move (compute-max g 0 *alpha-max* *beta-max* nil)))
    (format t "The amount of moves computed was: ~A~%" *node-count*)
    (if (equal best-move -100000)
	(format t "YOU LOSE!"))
    (if (equal best-move 100000)
	(format t "YOU WIN!"))
    (format t "did i make it back in one piece???~%")
    best-move))
    

(defparameter *cutoff-depth* 5)
(defparameter *alpha-max* -10000000)
(defparameter *beta-max* 10000000)
(defparameter *node-count* 0)

;;; COMPUTE-MAX
;;; ------------------------------
;;; INPUT: G, a CHESS struct
;;; N, CURRENT LEVEL
;;; A, alpha value
;;; B, beta value
;;; M, the 'best move so far'
;;; OUTPUT: ALPHA VALUE
;;; OR best move so far (at depth 0)

(defun compute-max (g n alpha beta m)
  (format t "~A: DO A MAX: ~A~%" n alpha)
  (cond
   ((game-over? g)
    (format t "max: do i hit game over?")
    -100000)
   ((equal n *cutoff-depth*)
    (format t "MAX: CUTOFF DEPTH REACHED: ~A~%" (eval-func2 g))
    (eval-func2 g))
   (t
    (mapcar #'(lambda (x)
		(format t "max: mapcar is doing this move: ~A, depth~A~%" x n)
		(apply #'do-move! g nil x)
		(format t "post-pruning move~%")
		(incf *node-count*)
		(let* ((beta-value (compute-min
				    g (+ 1 n) alpha beta m)))
		  (format t "TIME TO UNDO A MOVE!!!~%")
		  (undo-move! g)
		  (cond
		   ((> beta-value alpha)
		    (setf alpha beta-value)
		    (setf m x)
		    (format t "xxxxxxxxxxxxxxxxxxxxxxxmax: OKAY SO AT DEPTH ~A, ALPHA IS ~A~%: " n alpha)
		    (if (<= beta alpha)
			(return-from compute-max alpha))
		    ))))
	    (legal-moves g))
    (if (equal n 0)
	m
      alpha))))

;;; COMPUTE-MIN
;;; ------------------------------
;;; INPUT: G, a CHESS struct
;;; N, CURRENT LEVEL
;;; B, beta value
;;; M, the 'best move so far'
;;; OUTPUT: BETA VALUE

(defun compute-min (g n alpha beta m)
  (format t "~A: DO A MIN: ~A~%" n beta)
  (cond
   ((game-over? g)
    (format t "min: do i hit game over?")
    100000)
   ((equal n *cutoff-depth*)
    (format t "MIN: CUTOFF DEPTH REACHED: ~A~%" (eval-func2 g))
    (eval-func2 g))
   (t
    ;(format t "legal moves: ~A~%" (legal-moves g))
    (mapcar #'(lambda (x)
		(format t "min: mapcar is doing this move: ~A, depth~A~%" x n)
		(apply #'do-move! g nil x)
		(incf *node-count*)
		(let* ((alpha-value (compute-max
				     g (+ 1 n) alpha beta m)))
		  (format t "TIME TO UNDO A MOVE!!!~%")
		  (undo-move! g)
		  (cond
		   ((< alpha-value beta)
		    (setf beta alpha-value)
		    (setf m x)
		   (if (<= beta alpha)
		       (return-from compute-min beta))	    
		   (format t "xxxxxxxxxxmin: OKAY SO AT DEPTH ~A, BETA IS ~A~%: " n beta)))))
	    (legal-moves g))
    beta)))

;;; EVAL-FUNC
;;; ------------------
;;; INPUT: G, a CHESS struct
;;; N, current depth (for turn)
;;; OUTPUT: A value that repesents the
;;; static evaluation function

(defun eval-func (g)
  (let* ((white-subtotal (svref (chess-eval-subtotals g) 0))
	 (black-subtotal (svref (chess-eval-subtotals g) 1)))
    ;;; assuming white goes first
    (- white-subtotal black-subtotal)))
    ;(cond
     ;((evenp n)
      ;(- white-subtotal black-subtotal))
     ;(t
      ;(- black-subtotal white-subtotal)))))

(defun eval-func2 (g)
  (let* ((all-pieces (chess-pieces g))
	 (total 0))
    (dotimes (i 2)
      (dotimes (j 16)
	(let* ((current-piece (aref all-pieces i j))
	       (type (piece-type current-piece))
	       (current-owner (piece-owner current-piece)))
	  (cond
	   ((not (piece-live? current-piece))
	    0)
	   ((and
	     (eq type *pawn*)
	     (equal current-owner 0))
	    (setf total (+ total 100)))
	   ((and
	     (eq type *knight*)
	     (equal current-owner 0))
	    (setf total (+ total 300)))
	   ((and
	     (eq type *bishop*)
	     (equal current-owner 0))
	    (setf total (+ total 350)))
	   ((and
	     (eq type *rook*)
	     (equal current-owner 0))
	    (setf total (+ total 500)))
	   ((and
	     (eq type *queen*)
	     (equal current-owner 0))
	    (setf total (+ total 975)))
	   ((and
	     (eq type *king*)
	     (equal current-owner 0))
	    (setf total (+ total 100000)))
	   ((and
	     (eq type *pawn*)
	     (equal current-owner 1))
	    (setf total (- total 100)))
	   ((and
	     (eq type *knight*)
	     (equal current-owner 1))
	    (setf total (- total 300)))
	   ((and
	     (eq type *bishop*)
	     (equal current-owner 1))
	    (setf total (- total 350)))
	   ((and
	     (eq type *rook*)
	     (equal current-owner 1))
	    (setf total (- total 500)))
	   ((and
	     (eq type *queen*)
	     (equal current-owner 1))
	    (setf total (- total 975)))
	   ((and
	     (eq type *king*)
	     (equal current-owner 1))
	    (setf total (- total 100000)))))))
    total))